// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                     String                   @id @default(cuid())
  name                   String?
  email                  String?                  @unique
  emailVerified          DateTime?
  username               String?                  @unique
  role                   Role                     @default(USER)
  image                  String?
  accounts               Account[]
  sessions               Session[]
  eventVerifications     UserEventVerification[]
  event                  Event[]
  person                 Person[]
  work                   Work[]
  usersVotesACandidate   UsersVotesACandidate[]
  userPersonVerification UserPersonVerification[]
}

model Event {
  uid                   String                  @id @unique @default(cuid())
  title                 String
  locationsM            Json?
  comment               String?
  date                  DateTime?
  category              Category
  stateVerification     StateVerification?      @default(NONE)
  worksM                Json?
  works                 Work[]
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  creator               User?                   @relation(fields: [creatorId], references: [id])
  creatorId             String
  userEventVerification UserEventVerification[]
  link                  String?
  personsM              Json?
  persons               Person?                 @relation(fields: [personUid], references: [uid])
  personUid             String?

  @@index([title])
  @@index([creatorId])
}

model UserEventVerification {
  event             Event             @relation(fields: [eventId], references: [uid])
  eventId           String            @id @unique
  user              User              @relation(fields: [userId], references: [id])
  userId            String
  stateVerification StateVerification @default(NONE)

  @@index([userId, eventId])
}

model Person {
  uid               String             @id @unique @default(cuid())
  mUid              String?            @unique
  biography         Biography?
  title             String
  stateVerification StateVerification? @default(NONE)
  occupations       Occupations[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  creator           User?              @relation(fields: [creatorId], references: [id])
  creatorId         String
  link              String?
  events            Event[]

  composerOf             PersonWorkReleation[]    @relation("ComposerOf")
  performerOf            PersonWorkReleation[]    @relation("PerformerOf")
  arrangerOf             PersonWorkReleation[]    @relation("ArrangerOf")
  userPersonVerification UserPersonVerification[]

  @@index([creatorId])
}

model UserPersonVerification {
  person            Person            @relation(fields: [personId], references: [uid])
  personId          String            @id @unique
  user              User              @relation(fields: [userId], references: [id])
  userId            String
  stateVerification StateVerification @default(NONE)

  @@index([userId, personId])
}

model Occupations {
  id             Int        @id @default(autoincrement())
  occupation     Occupation
  OccupationList Person     @relation(fields: [personUid], references: [uid])
  personUid      String

  @@index([personUid])
}

model Biography {
  person    Person    @relation(fields: [personUid], references: [uid])
  personUid String    @id @unique
  birth     DateTime?
  death     DateTime?
}

model PersonWorkReleation {
  work      Work     @relation(fields: [workUid], references: [uid])
  workUid   String   @id @unique
  composer  Person[] @relation("ComposerOf")
  arranger  Person[] @relation("ArrangerOf")
  performer Person[] @relation("PerformerOf")
}

model Work {
  uid                 String               @id @unique @default(cuid())
  mUid                String?              @unique
  title               String
  dates               String?
  description         String?
  createdAt           DateTime?            @default(now())
  updatedAt           DateTime?            @updatedAt
  creator             User                 @relation(fields: [creatorId], references: [id])
  creatorId           String
  Events              Event[]
  PersonWorkReleation PersonWorkReleation?

  @@index([creatorId])
}

enum Category {
  Season
  Concert
  Religious_Event
  Music_Theater
}

enum Role {
  USER
  ADMIN
}

enum StateVerification {
  PENDING
  VERIFIED
  REJECTED
  NONE
}

enum Occupation {
  Composer
  Arranger
  Performer
  Librettist
  Poet
}

// modelli per la gestione di locationM senza coordinate

model Location {
  uid        String  @id @unique @default(cuid())
  mUid       String? @unique
  title      String
  slug       String?
  geometries Json?
}

model LocationMC {
  uid                  String                @id @unique // this is the same as the locationM
  coordinateCandidates CoordinateCandidate[]

  @@index([uid])
}

model CoordinateCandidate {
  coordinateCandidateId Int // lo stesso di geoMap
  locationMC            LocationMC             @relation(fields: [locationMCId], references: [uid])
  locationMCId          String
  locationName          String
  lat                   String
  lon                   String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  votes                 UsersVotesACandidate[]

  @@unique([locationMCId, coordinateCandidateId]) // Adding unique constraint on locationMCId and coordinateCandidateId
  @@unique([coordinateCandidateId, locationMCId])
  @@index([locationMCId, coordinateCandidateId])
}

model UsersVotesACandidate {
  user                  User                @relation(fields: [userId], references: [id])
  userId                String
  coordinateCandidate   CoordinateCandidate @relation(fields: [coordinateCandidateId, locationMCId], references: [coordinateCandidateId, locationMCId])
  coordinateCandidateId Int
  locationMCId          String

  @@unique([userId, locationMCId])
  @@index([userId, locationMCId])
  @@index([coordinateCandidateId, locationMCId])
}
